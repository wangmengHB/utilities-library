# Event Emitter
The Event Emitter in vscode has the following features:    
* 1. Emitter (all the event emitters ) : 
	* NO Event Name Concept		
	* Any Exception Occurrence in handler will not block the execuation of other handlers	  
	* In-Order delivery, especially in the scenarior of firing event in handler       
* 2. PauseableEmitter (extends Emitter)	
* 3. AsyncEmitter (extends Emitter)	
* 4. EventMultiplexer (util for emitter)
* 5. EventBufferer (util for emitter)	
* 6. Event Utils (other util functions under the namespace `Event`)
	* Event.buffer, 
	* Event.once, 
	* Event.stopwatch, 
	* Event.fromPromise,
	* Event.debounce

## 1. Emitter
### 1.1. No Event Name Concept
Unlike other event emitter (the `on/off/trigger` in jQuery), there is NO event name concept in the event emitter of vscode. It assumps that managing the event name is not a good idea. Event Name should be clearly defined in your system, instead of freely defined by the end user.   
```ts
import { Event, Emitter, IDisposable } from 'util-kit';

const emitter: Emitter<string> = new Emitter<string>();

function listener(value: string) { ... }

// register event listener
const subscription: IDisposable = emitter.event(listener);

// fire the event
emitter.fire('event value');

// remove and dispose the event listener
subscription.dispose();
```

### 1.2. This Event Emitter will not block other handlers' execuation if any of them throw exception. For example: 
```ts
let emitter = new Emitter<undefined>();
let hit = false;
emitter.event(function () {
    throw new Error('some thing bad!');
});
emitter.event(function () {
    hit = true;
});
emitter.fire(undefined);
console.log('hit', hit);    // hit true
```

### 1.3. Event is delivered in order. If any event fire take place in a listener, it will push the event in the current delivery queue, and flush it immediately. For example:  
```ts
import { Event, Emitter, IDisposable } from 'util-kit';
const a = new Emitter<string>();
const values: string[] = [];

a.event(function listener1(val) {
    if (val === 'e1') {
        a.fire('e2');
        // a.fire('e2') means:
        // push 'e2' in current delivery queue, and flush it.
        // which means: handler2('e1') -> handler1('e2') -> handler('e2')
        console.log(values) // ['e1', 'e2']
    }
});

a.event(function listener2(val) {
    values.push(val);
});

a.fire('e1');

// assert that all events are delivered in order
console.log(values); // ['e1', 'e2']
```
* Notice: Firing event in any handler should be aware of dead loop, condition statement is MUST.    

### 1.4. options in Emitter
* Emitter constructor: (options: EmitterOptions)
```ts
export interface EmitterOptions {
	onFirstListenerAdd?: Function;
	onFirstListenerDidAdd?: Function;
	onListenerDidAdd?: Function;
	onLastListenerRemove?: Function;
	leakWarningThreshold?: number;
}
```
* emitter.event(handler, context, disposalStore)
* emitter.fire(event: T)


## 2. PausableEmitter (extends Emitter)		
1. pause/resume: If the emitter is paused, it will not really fire any events until it is resumed. If it is paused serveral times, it must be resumed the same times.   	
2. support optional merge function as constructor parameter, used to merge event value during pause phase.
3. if pause ocurs in a listener, it means pause the next event cycle, not the current cycle.	

* use case 1
```ts
import { Event, Emitter, IDisposable, PausableEmitter } from 'util-kit';

const data: number[] = [];
const emitter = new PauseableEmitter<number>();

emitter.event(e => data.push(e));
emitter.fire(1);
emitter.fire(2);
console.log('result should be [1, 2]', data);	// [1, 2]

// pause twice here
emitter.pause();
emitter.pause();
emitter.fire(3);
emitter.fire(4);
console.log('result should be [1, 2]', data);	// [1, 2]

// resume once, the emitter is still paused	
emitter.resume();
console.log('result should be [1, 2]', data);	// [1, 2]

// resume twice, the emitter is resumed
emitter.resume();
console.log('result should be [1, 2, 3, 4]', data);	// [1, 2, 3, 4]

// dump resume, nothing happens
emitter.resume();
console.log('result should be [1, 2, 3, 4]', data);	// [1, 2, 3, 4]

emitter.fire(5);
console.log('result should be [1, 2, 3, 4, 5]', data);	// [1, 2, 3, 4, 5]
```
* use case 2: passing the merge function to do sth for the paused events.	 
```ts
import { Event, Emitter, IDisposable, PausableEmitter } from 'util-kit';

const data: number[] = [];
const emitter = new PauseableEmitter<number>({ merge: (a) => a.reduce((p, c) => p + c, 0) });

emitter.event(e => data.push(e));
emitter.fire(1);
emitter.fire(2);
console.log(data);	// [1, 2]

// pause the emitter 
emitter.pause();
emitter.fire(3);
emitter.fire(4);
console.log(data);	// [1, 2]

// resume the emitter, and the event data is merged during the pause phase
emitter.resume();
console.log(data);	// [1, 2, 7]

// behave as normal
emitter.fire(5);
console.log(data);	// [1, 2, 7, 5]

```
* use case 3
```ts
import { PausableEmitter } from 'util-kit';
import * as assert from 'assert';

const data: number[] = [];
const emitter = new PauseableEmitter<number>();

let once = true;
emitter.event(e => {
	data.push(e);
	if (once) {
		// pause the next event cycle, not the current.		
		emitter.pause();
		once = false;
	}
});
emitter.event(e => {
	data.push(e);
});

emitter.pause();
emitter.fire(1);
emitter.fire(2);
console.log('result should be []', data);

emitter.resume();
console.log('result should be [1, 1]', data); 
// paused in the first hanlder, but current cycle will not be blocked

emitter.resume();
console.log('result should be [1, 1, 2, 2]', data); 
// remaining event delivered

emitter.fire(3);
console.log('result should be [1, 1, 2, 2, 3, 3]', data); 
```

## 3. AsyncEmitter (extends Emitter)
1. has an async `fireAsync` method, it accepts 2 parameters: event data, and CancellationToken. (`CancellationToken.None` is used in most case,  `CancellationToken.Cancelled` is used to pause this fireAsync Action, the event is still in the async delivery queue, which will be executed next time)  	
2. the event parameter in listener has an `waitUntil` function property, it accept a promise as input parameter. The other listener will not be called until the promise is resolved.   
3. Error will never block other listener or can be catched by `fireAsync`, neither error in listener or promise in waitUntil. 		 

* use case 1: 
```ts
import { AsyncEmitter, CancellationToken, IWaitUntil, asyncs } from 'util-kit';
const { timeout } = asyncs;

interface E extends IWaitUntil {
	foo: boolean;
}

let globalState = 0;
let emitter = new AsyncEmitter<E>();
emitter.event(function listener1(e: E) {
	e.waitUntil(timeout(10).then(_ => {
		assert.equal(globalState, 0);
		globalState += 1;
	}));
});

// listener2 is not triggerred until the promise in waitUntil of listener1 is resolved
emitter.event(function listener2(e: E) {
	e.waitUntil(timeout(1).then(_ => {
		assert.equal(globalState, 1);
		globalState += 1;
	}));
});

await emitter.fireAsync({ foo: true }, CancellationToken.None);
assert.equal(globalState, 2);
```
* use case 2: 
```ts
interface E extends IWaitUntil {
	foo: number;
}
let events: number[] = [];
let done = false;
let emitter = new AsyncEmitter<E>();

// e1
emitter.event(e => {
	e.waitUntil(timeout(10).then(async _ => {
		if (e.foo === 1) {
			await emitter.fireAsync({ foo: 2 }, CancellationToken.None);
			assert.deepEqual(events, [1, 2]);
			done = true;
		}
	}));
});

// e2
emitter.event(e => {
	events.push(e.foo);
	e.waitUntil(timeout(7));
});

await emitter.fireAsync({ foo: 1 }, CancellationToken.None);
assert.ok(done);
```
* use case 3:
```ts
import { AsyncEmitter, CancellationToken, IWaitUntil, asyncs } from 'util-kit';
const { timeout } = asyncs;

interface E extends IWaitUntil {
	foo: boolean;
}

let globalState = 0;
let emitter = new AsyncEmitter<E>();

emitter.event(e => {
	globalState += 1;
	e.waitUntil(new Promise((_r, reject) => reject(new Error())));
});

emitter.event(e => {
	globalState += 1;
	e.waitUntil(timeout(10));
});

await emitter.fireAsync({ foo: true }, CancellationToken.None).then(() => {
	assert.equal(globalState, 2);
}).catch(e => {
	// error will never be catched here!
	console.log(e);
	assert.ok(false);
});

```


## 4. EventMultiplexer
EventMultiplexer is a helper class for managing multi emitters. You can use event multiplexer to register(event) listener or dispose for multiple events. 

```ts
import { Emitter, EventMultiplexer } from 'util-kit';

const result: number[] = [];
const m = new EventMultiplexer<number>();
m.event(r => result.push(r));

const e1 = new Emitter<number>();
m.add(e1.event);
const e2 = new Emitter<number>();
m.add(e2.event);

e1.fire(0);
console.log('result should be [0]', result);

e1.dispose();
console.log('result should be [0]', result);

e1.fire(1);
console.log('result should be [0]', result);

e2.fire(2);
console.log('result should be [0, 2]', result);

const e3 = new Emitter<number>();
const l3 = m.add(e3.event);
e3.fire(3);
console.log('result should be [0, 2, 3]', result);

l3.dispose();
e3.fire(4);
console.log('result should be [0, 2, 3]', result);

e2.fire(4);
e1.fire(5);
console.log('result should be [0, 2, 3, 4]', result);

```

## 6. EventBufferer
The EventBufferer is useful in situations in which you want to delay firing your events during some code. 
You can wrap that code and be sure that the event will not be fired during that wrap.
```ts 
import { 
	Event, Emitter, EventBufferer, EventMultiplexer, IWaitUntil, PauseableEmitter, AsyncEmitter 
} from 'util-kit';
const emitter: Emitter;
const delayer = new EventBufferer();
const delayedEvent = delayer.wrapEvent(emitter.event);

let count = 0;
let listener = () => count++;

delayedEvent(listener);
 
delayer.bufferEvents(() => {
	emitter.fire(); // event will not be fired yet
	console.log('count should be 0 ', count);
	emitter.fire(); // event will not be fired yet
	console.log('count should be 0 ', count);
});

// event will only be fired at this point
console.log('count should be 2 ', count);
emitter.fire();
console.log('count should be 3 ', count);

```



## Event Utils: latch, buffer, once, debounce, stopwatch, fromPromise
Event is a namespace, there are some util function in this namespace, mainly used to wrap the `emitter.event` function, to make it has some special features: such as latch, once, buffer etc.

### Event.latch ( event data will be latched )
The handler will not be triggered if the event data is the same as last time. 

```ts
import { Event, Emitter } from 'util-kit';
const emitter = new Emitter<number>();
const event = Event.latch(emitter.event);

const result: number[] = [];
const listener = event(num => result.push(num));

assert.deepEqual(result, []);

emitter.fire(1);
assert.deepEqual(result, [1]);

emitter.fire(2);
assert.deepEqual(result, [1, 2]);

emitter.fire(2);
assert.deepEqual(result, [1, 2]);

emitter.fire(1);
assert.deepEqual(result, [1, 2, 1]);

emitter.fire(1);
assert.deepEqual(result, [1, 2, 1]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

listener.dispose();

```

### Event.once ( listeners will be called only once )
The handler will only be triggered once when event fired.
```ts
const emitter = new Emitter<void>();

let counter1 = 0, counter2 = 0, counter3 = 0;

const listener1 = emitter.event(() => counter1++);
const listener2 = Event.once(emitter.event)(() => counter2++);
const listener3 = Event.once(emitter.event)(() => counter3++);

assert.equal(counter1, 0);
assert.equal(counter2, 0);
assert.equal(counter3, 0);

listener3.dispose();
emitter.fire();
assert.equal(counter1, 1);
assert.equal(counter2, 1);
assert.equal(counter3, 0);

emitter.fire();
assert.equal(counter1, 2);
assert.equal(counter2, 1);
assert.equal(counter3, 0);

listener1.dispose();
listener2.dispose();
```

### Event.stopwatch
Given an event, it returns another event which fires only once and as soon as the input event emits. The event data is the number of millis it took for the event to fire.

```ts
const emitter = new Emitter<void>();
const event = Event.stopwatch(emitter.event);

event(duration => {
	console.log(duration);
});

setTimeout(() => emitter.fire(), 10);
```



### Event.buffer<T>(emitter.event, isNextTick = false, initData: T[] = [])
Buffers the provided event until a first listener comes along, at which point fire all the events at once and pipe the event from then on.	
* emitter.event: or other event function.			
* isNextTick: whether to fire in the next tick.		
* initData: an array of event data need to be fired sequential as intial fires.

`Event.buffer` only works for the FIRST listener when it is registered.		

```ts
import { Event, Emitter } from 'util-kit';
const result: number[] = [];
const emitter = new Emitter<number>();
// nothing happens.	
emitter.fire(-100);
const bufferedEvent = Event.buffer(emitter.event, false, [-2, -1, 0]);

// the event fired as below will be buffered
emitter.fire(1);
emitter.fire(2);
emitter.fire(3);
console.log('result should be []', result);

// the buffered events will be fired once the first listener registered.
// And only works for the first listener	
const sub1 = bufferedEvent(num => result.push(num));
console.log('result should be [-2, -1, 0, 1, 2, 3]', result);

sub1.dispose();
emitter.fire(4);
// the above fire will not be buffered.
const sub2 = bufferedEvent(num => result.push(num));
// there is no 4 in the result.	
console.log('result should be [-2, -1, 0, 1, 2, 3]', result);
```






### fromPromise
fromPromise is not a `emitter.event` wrapper, it accept a promise, and return an event function. The listener will be called immediately after the promise resolved. 
It functions like the `process.nextTick`.		

```ts
import { 
	Event, Emitter, EventBufferer, EventMultiplexer, IWaitUntil, PauseableEmitter, AsyncEmitter 
} from 'util-kit';

let count = 0;
const promise = timeout(5);
const event = Event.fromPromise(promise);
// listener will be fired after the promise is resolved.
event(() => count++);

assert.equal(count, 0);
await promise;
assert.equal(count, 1);

```

### Event.debounce
```ts
test('Debounce Event', function (done: () => void) {
		let doc = new Samples.Document3();

		let onDocDidChange = Event.debounce(doc.onDidChange, (prev: string[] | undefined, cur) => {
			if (!prev) {
				prev = [cur];
			} else if (prev.indexOf(cur) < 0) {
				prev.push(cur);
			}
			return prev;
		}, 10);

		let count = 0;

		onDocDidChange(keys => {
			count++;
			assert.ok(keys, 'was not expecting keys.');
			if (count === 1) {
				doc.setText('4');
				assert.deepEqual(keys, ['1', '2', '3']);
			} else if (count === 2) {
				assert.deepEqual(keys, ['4']);
				done();
			}
		});

		doc.setText('1');
		doc.setText('2');
		doc.setText('3');
	});

	test('Debounce Event - leading', async function () {
		const emitter = new Emitter<void>();
		let debounced = Event.debounce(emitter.event, (l, e) => e, 0, /*leading=*/true);

		let calls = 0;
		debounced(() => {
			calls++;
		});

		// If the source event is fired once, the debounced (on the leading edge) event should be fired only once
		emitter.fire();

		await timeout(1);
		assert.equal(calls, 1);
	});

	test('Debounce Event - leading', async function () {
		const emitter = new Emitter<void>();
		let debounced = Event.debounce(emitter.event, (l, e) => e, 0, /*leading=*/true);

		let calls = 0;
		debounced(() => {
			calls++;
		});

		// If the source event is fired multiple times, the debounced (on the leading edge) event should be fired twice
		emitter.fire();
		emitter.fire();
		emitter.fire();
		await timeout(1);
		assert.equal(calls, 2);
	});

	test('Debounce Event - leading reset', async function () {
		const emitter = new Emitter<number>();
		let debounced = Event.debounce(emitter.event, (l, e) => l ? l + 1 : 1, 0, /*leading=*/true);

		let calls: number[] = [];
		debounced((e) => calls.push(e));

		emitter.fire(1);
		emitter.fire(1);

		await timeout(1);
		assert.deepEqual(calls, [1, 1]);
	});

```









```ts

import * as assert from 'assert';
import { Event, Emitter, EventBufferer, EventMultiplexer, IWaitUntil, PauseableEmitter, AsyncEmitter } from 'vs/base/common/event';
import { IDisposable, DisposableStore } from 'vs/base/common/lifecycle';
import * as Errors from 'vs/base/common/errors';
import { timeout } from 'vs/base/common/async';
import { CancellationToken } from 'vs/base/common/cancellation';

namespace Samples {

	export class EventCounter {

		count = 0;

		reset() {
			this.count = 0;
		}

		onEvent() {
			this.count += 1;
		}
	}

	export class Document3 {

		private readonly _onDidChange = new Emitter<string>();

		onDidChange: Event<string> = this._onDidChange.event;

		setText(value: string) {
			//...
			this._onDidChange.fire(value);
		}

	}
}

suite('Event', function () {

	

	test('Emitter, bucket', function () {

		let bucket: IDisposable[] = [];
		let doc = new Samples.Document3();
		let subscription = doc.onDidChange(counter.onEvent, counter, bucket);

		doc.setText('far');
		doc.setText('boo');

		// unhook listener
		while (bucket.length) {
			bucket.pop()!.dispose();
		}
		doc.setText('boo');

		// noop
		subscription.dispose();

		doc.setText('boo');
		assert.equal(counter.count, 2);
	});

	test('Emitter, store', function () {

		let bucket = new DisposableStore();
		let doc = new Samples.Document3();
		let subscription = doc.onDidChange(counter.onEvent, counter, bucket);

		doc.setText('far');
		doc.setText('boo');

		// unhook listener
		bucket.clear();
		doc.setText('boo');

		// noop
		subscription.dispose();

		doc.setText('boo');
		assert.equal(counter.count, 2);
	});

	test('onFirstAdd|onLastRemove', () => {

		let firstCount = 0;
		let lastCount = 0;
		let a = new Emitter({
			onFirstListenerAdd() { firstCount += 1; },
			onLastListenerRemove() { lastCount += 1; }
		});

		assert.equal(firstCount, 0);
		assert.equal(lastCount, 0);

		let subscription = a.event(function () { });
		assert.equal(firstCount, 1);
		assert.equal(lastCount, 0);

		subscription.dispose();
		assert.equal(firstCount, 1);
		assert.equal(lastCount, 1);

		subscription = a.event(function () { });
		assert.equal(firstCount, 2);
		assert.equal(lastCount, 1);
	});

	

	

	

	
});


```