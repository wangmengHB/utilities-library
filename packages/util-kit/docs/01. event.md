# Event Emitter

The Event Emitter in vscode has some special design:    
* NO Event Name Concept, each emitter represent one event name      
* Any Exception Occurrence in listener will not block the execuation of other listeners  
* Event is delivered in Order, especially in the scenarior of firing event in listener       
* PauseableEmitter		
* AsyncEmitter
* Event Utils: latch, buffer, once, stopwatch
* EventBufferer
* 


## No Event Name Concept
There is NO event name concept in the event emitter of vscode. It assumps that managing the event name is not a good idea. Event Name should be clearly defined in your system, instead of freely defined by the end user.   
```ts
import { Event, Emitter, IDisposable } from 'util-kit';

const emitter: Emitter<string> = new Emitter<string>();

function listener(value: string) { ... }

// register event listener
const subscription: IDisposable = emitter.event(listener);

// fire the event
emitter.fire('event value');

// remove and dispose the event listener
subscription.dispose();
```

In vscode's code style, it is preferred to split the event and the fire apart. like: 
```ts
import { Event, Emitter, IDisposable } from 'util-kit';

const _onDidChange: Emitter<string> = new Emitter<string>();
const onDidChange: Event<string> = _onDidChange.event;

function handler(value: string) { ... }
// register event handler
const subscription: IDisposable = onDidChange(handler);

// fire the event
_onDidChange.fire('event value');

// remove and dispose the event handler
subscription.dispose();
```

## This Event Emitter will not block other handlers' execuation if any of them throw exception. For example: 
```ts
let emitter = new Emitter<undefined>();
let hit = false;
emitter.event(function () {
    throw new Error('some thing bad!');
});
emitter.event(function () {
    hit = true;
});
emitter.fire(undefined);
console.log('hit', hit);    // hit true
```

## Event is delivered in order. If any event fire take place in a listener, it will push the event in the current delivery queue, and flush it immediately. For example:  
```ts
import { Event, Emitter, IDisposable } from 'util-kit';
const a = new Emitter<string>();
const values: string[] = [];

a.event(function listener1(val) {
    if (val === 'e1') {
        a.fire('e2');
        // a.fire('e2') means:
        // push 'e2' in current delivery queue, and flush it.
        // which means: handler2('e1') -> handler1('e2') -> handler('e2')
        console.log(values) // ['e1', 'e2']
    }
});

a.event(function listener2(val) {
    values.push(val);
});

a.fire('e1');

// assert that all events are delivered in order
console.log(values); // ['e1', 'e2']
```
* Notice: Firing event in any listener should be aware of dead loop, condition statement is MUST.    



## PausableEmitter (extends Emitter)		
1. pause/resume: If the emitter is paused, it will not really fire any events until it is resumed. If it is paused serveral times, it must be resumed the same times.   	
2. support optional merge function as constructor parameter, used to merge event value during pause phase.
3. if pause ocurs in a listener, it means pause the next event cycle, not the current cycle.	

* use case 1
```ts
import { Event, Emitter, IDisposable, PausableEmitter } from 'util-kit';

const data: number[] = [];
const emitter = new PauseableEmitter<number>();

emitter.event(e => data.push(e));
emitter.fire(1);
emitter.fire(2);
console.log(data);	// [1, 2]

// pause twice here
emitter.pause();
emitter.pause();
emitter.fire(3);
emitter.fire(4);
console.log(data);	// [1, 2]

// resume once, the emitter is still paused	
emitter.resume();
console.log(data);	// [1, 2]

// resume twice, the emitter is resumed
emitter.resume();
console.log(data);	// [1, 2, 3, 4]

// dump resume, nothing happens
emitter.resume();
console.log(data);	// [1, 2, 3, 4]

emitter.fire(5);
console.log(data);	// [1, 2, 3, 4, 5]
```
* use case 2
```ts
import { Event, Emitter, IDisposable, PausableEmitter } from 'util-kit';

const data: number[] = [];
const emitter = new PauseableEmitter<number>({ merge: (a) => a.reduce((p, c) => p + c, 0) });

emitter.event(e => data.push(e));
emitter.fire(1);
emitter.fire(2);
console.log(data);	// [1, 2]

// pause the emitter 
emitter.pause();
emitter.fire(3);
emitter.fire(4);
console.log(data);	// [1, 2]

// resume the emitter, and the event data is merged during the pause phase
emitter.resume();
console.log(data);	// [1, 2, 7]

// behave as normal
emitter.fire(5);
console.log(data);	// [1, 2, 7, 5]

```
* use case 3
```ts
import { PausableEmitter } from 'util-kit';
import * as assert from 'assert';

const data: number[] = [];
const emitter = new PauseableEmitter<number>();

let once = true;
emitter.event(e => {
	data.push(e);
	if (once) {
		// pause the next event cycle, not the current.		
		emitter.pause();
		once = false;
	}
});
emitter.event(e => {
	data.push(e);
});

emitter.pause();
emitter.fire(1);
emitter.fire(2);
assert.deepEqual(data, []);

emitter.resume();
assert.deepEqual(data, [1, 1]); // paused after first event

emitter.resume();
assert.deepEqual(data, [1, 1, 2, 2]); // remaing event delivered

emitter.fire(3);
assert.deepEqual(data, [1, 1, 2, 2, 3, 3]);
```



## AsyncEmitter (extends Emitter)
1. has an async `fireAsync` method, it accepts 2 parameters: event data, and CancellationToken. (`CancellationToken.None` is used in most case,  `CancellationToken.Cancelled` is used to pause this fireAsync Action, the event is still in the async delivery queue, which will be executed next time)  	
2. the event parameter in listener has an `waitUntil` function property, it accept a promise as input parameter. The other listener will not be called until the promise is resolved.   
3. Error will never block other listener or can be catched by `fireAsync`, neither error in listener or promise in waitUntil. 		 

* use case 1: 
```ts
import { AsyncEmitter, CancellationToken, IWaitUntil, asyncs } from 'util-kit';
const { timeout } = asyncs;

interface E extends IWaitUntil {
	foo: boolean;
}

let globalState = 0;
let emitter = new AsyncEmitter<E>();
emitter.event(function listener1(e: E) {
	e.waitUntil(timeout(10).then(_ => {
		assert.equal(globalState, 0);
		globalState += 1;
	}));
});

// listener2 is not triggerred until the promise in waitUntil of listener1 is resolved
emitter.event(function listener2(e: E) {
	e.waitUntil(timeout(1).then(_ => {
		assert.equal(globalState, 1);
		globalState += 1;
	}));
});

await emitter.fireAsync({ foo: true }, CancellationToken.None);
assert.equal(globalState, 2);
```
* use case 2: 
```ts
interface E extends IWaitUntil {
	foo: number;
}
let events: number[] = [];
let done = false;
let emitter = new AsyncEmitter<E>();

// e1
emitter.event(e => {
	e.waitUntil(timeout(10).then(async _ => {
		if (e.foo === 1) {
			await emitter.fireAsync({ foo: 2 }, CancellationToken.None);
			assert.deepEqual(events, [1, 2]);
			done = true;
		}
	}));
});

// e2
emitter.event(e => {
	events.push(e.foo);
	e.waitUntil(timeout(7));
});

await emitter.fireAsync({ foo: 1 }, CancellationToken.None);
assert.ok(done);
```
* use case 3:
```ts
import { AsyncEmitter, CancellationToken, IWaitUntil, asyncs } from 'util-kit';
const { timeout } = asyncs;

interface E extends IWaitUntil {
	foo: boolean;
}

let globalState = 0;
let emitter = new AsyncEmitter<E>();

emitter.event(e => {
	globalState += 1;
	e.waitUntil(new Promise((_r, reject) => reject(new Error())));
});

emitter.event(e => {
	globalState += 1;
	e.waitUntil(timeout(10));
});

await emitter.fireAsync({ foo: true }, CancellationToken.None).then(() => {
	assert.equal(globalState, 2);
}).catch(e => {
	// error will never be catched here!
	console.log(e);
	assert.ok(false);
});

```


## Event Utils: latch, buffer, once, debounce, stopwatch, fromPromise
Event is a namespace, there are some util function in this namespace, mainly used to wrap the `emitter.event` function, to make it has some special features: such as latch, once, buffer etc.

### latch ( event data will be latched )
```ts
import { Event, Emitter } from 'util-kit';
const emitter = new Emitter<number>();
const event = Event.latch(emitter.event);

const result: number[] = [];
const listener = event(num => result.push(num));

assert.deepEqual(result, []);

emitter.fire(1);
assert.deepEqual(result, [1]);

emitter.fire(2);
assert.deepEqual(result, [1, 2]);

emitter.fire(2);
assert.deepEqual(result, [1, 2]);

emitter.fire(1);
assert.deepEqual(result, [1, 2, 1]);

emitter.fire(1);
assert.deepEqual(result, [1, 2, 1]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

emitter.fire(3);
assert.deepEqual(result, [1, 2, 1, 3]);

listener.dispose();

```

### once ( listeners will be called only once )
```ts
const emitter = new Emitter<void>();

let counter1 = 0, counter2 = 0, counter3 = 0;

const listener1 = emitter.event(() => counter1++);
const listener2 = Event.once(emitter.event)(() => counter2++);
const listener3 = Event.once(emitter.event)(() => counter3++);

assert.equal(counter1, 0);
assert.equal(counter2, 0);
assert.equal(counter3, 0);

listener3.dispose();
emitter.fire();
assert.equal(counter1, 1);
assert.equal(counter2, 1);
assert.equal(counter3, 0);

emitter.fire();
assert.equal(counter1, 2);
assert.equal(counter2, 1);
assert.equal(counter3, 0);

listener1.dispose();
listener2.dispose();
```

### stopwatch
Given an event, it returns another event which fires only once and as soon as the input event emits. The event data is the number of millis it took for the event to fire.

```ts
const emitter = new Emitter<void>();
const event = Event.stopwatch(emitter.event);

event(duration => {
	console.log(duration);
});

setTimeout(() => emitter.fire(), 10);
```

### buffer

### EventMultiplexer



### fromPromise
fromPromise is not a `emitter.event` wrapper, it accept a promise, and return an event function. The listener will be called immediately after the promise resolved. 
It functions like the `process.nextTick`.		


```ts

let count = 0;
const promise = timeout(5);
const event = Event.fromPromise(promise);
// listener will be fired after the promise is resolved.
event(() => count++);

assert.equal(count, 0);
await promise;
assert.equal(count, 1);

```









```ts
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import * as assert from 'assert';
import { Event, Emitter, EventBufferer, EventMultiplexer, IWaitUntil, PauseableEmitter, AsyncEmitter } from 'vs/base/common/event';
import { IDisposable, DisposableStore } from 'vs/base/common/lifecycle';
import * as Errors from 'vs/base/common/errors';
import { timeout } from 'vs/base/common/async';
import { CancellationToken } from 'vs/base/common/cancellation';

namespace Samples {

	export class EventCounter {

		count = 0;

		reset() {
			this.count = 0;
		}

		onEvent() {
			this.count += 1;
		}
	}

	export class Document3 {

		private readonly _onDidChange = new Emitter<string>();

		onDidChange: Event<string> = this._onDidChange.event;

		setText(value: string) {
			//...
			this._onDidChange.fire(value);
		}

	}
}

suite('Event', function () {

	const counter = new Samples.EventCounter();

	setup(() => counter.reset());

	test('Emitter plain', function () {

		let doc = new Samples.Document3();

		// document.createElement('div').onclick = function () { };
		let subscription = doc.onDidChange(counter.onEvent, counter);

		doc.setText('far');
		doc.setText('boo');

		// unhook listener
		subscription.dispose();
		doc.setText('boo');
		assert.equal(counter.count, 2);
	});


	test('Emitter, bucket', function () {

		let bucket: IDisposable[] = [];
		let doc = new Samples.Document3();
		let subscription = doc.onDidChange(counter.onEvent, counter, bucket);

		doc.setText('far');
		doc.setText('boo');

		// unhook listener
		while (bucket.length) {
			bucket.pop()!.dispose();
		}
		doc.setText('boo');

		// noop
		subscription.dispose();

		doc.setText('boo');
		assert.equal(counter.count, 2);
	});

	test('Emitter, store', function () {

		let bucket = new DisposableStore();
		let doc = new Samples.Document3();
		let subscription = doc.onDidChange(counter.onEvent, counter, bucket);

		doc.setText('far');
		doc.setText('boo');

		// unhook listener
		bucket.clear();
		doc.setText('boo');

		// noop
		subscription.dispose();

		doc.setText('boo');
		assert.equal(counter.count, 2);
	});

	test('onFirstAdd|onLastRemove', () => {

		let firstCount = 0;
		let lastCount = 0;
		let a = new Emitter({
			onFirstListenerAdd() { firstCount += 1; },
			onLastListenerRemove() { lastCount += 1; }
		});

		assert.equal(firstCount, 0);
		assert.equal(lastCount, 0);

		let subscription = a.event(function () { });
		assert.equal(firstCount, 1);
		assert.equal(lastCount, 0);

		subscription.dispose();
		assert.equal(firstCount, 1);
		assert.equal(lastCount, 1);

		subscription = a.event(function () { });
		assert.equal(firstCount, 2);
		assert.equal(lastCount, 1);
	});

	

	

	test('Debounce Event', function (done: () => void) {
		let doc = new Samples.Document3();

		let onDocDidChange = Event.debounce(doc.onDidChange, (prev: string[] | undefined, cur) => {
			if (!prev) {
				prev = [cur];
			} else if (prev.indexOf(cur) < 0) {
				prev.push(cur);
			}
			return prev;
		}, 10);

		let count = 0;

		onDocDidChange(keys => {
			count++;
			assert.ok(keys, 'was not expecting keys.');
			if (count === 1) {
				doc.setText('4');
				assert.deepEqual(keys, ['1', '2', '3']);
			} else if (count === 2) {
				assert.deepEqual(keys, ['4']);
				done();
			}
		});

		doc.setText('1');
		doc.setText('2');
		doc.setText('3');
	});

	test('Debounce Event - leading', async function () {
		const emitter = new Emitter<void>();
		let debounced = Event.debounce(emitter.event, (l, e) => e, 0, /*leading=*/true);

		let calls = 0;
		debounced(() => {
			calls++;
		});

		// If the source event is fired once, the debounced (on the leading edge) event should be fired only once
		emitter.fire();

		await timeout(1);
		assert.equal(calls, 1);
	});

	test('Debounce Event - leading', async function () {
		const emitter = new Emitter<void>();
		let debounced = Event.debounce(emitter.event, (l, e) => e, 0, /*leading=*/true);

		let calls = 0;
		debounced(() => {
			calls++;
		});

		// If the source event is fired multiple times, the debounced (on the leading edge) event should be fired twice
		emitter.fire();
		emitter.fire();
		emitter.fire();
		await timeout(1);
		assert.equal(calls, 2);
	});

	test('Debounce Event - leading reset', async function () {
		const emitter = new Emitter<number>();
		let debounced = Event.debounce(emitter.event, (l, e) => l ? l + 1 : 1, 0, /*leading=*/true);

		let calls: number[] = [];
		debounced((e) => calls.push(e));

		emitter.fire(1);
		emitter.fire(1);

		await timeout(1);
		assert.deepEqual(calls, [1, 1]);
	});

	
});




suite('Event utils', () => {

	suite('EventBufferer', () => {

		test('should not buffer when not wrapped', () => {
			const bufferer = new EventBufferer();
			const counter = new Samples.EventCounter();
			const emitter = new Emitter<void>();
			const event = bufferer.wrapEvent(emitter.event);
			const listener = event(counter.onEvent, counter);

			assert.equal(counter.count, 0);
			emitter.fire();
			assert.equal(counter.count, 1);
			emitter.fire();
			assert.equal(counter.count, 2);
			emitter.fire();
			assert.equal(counter.count, 3);

			listener.dispose();
		});

		test('should buffer when wrapped', () => {
			const bufferer = new EventBufferer();
			const counter = new Samples.EventCounter();
			const emitter = new Emitter<void>();
			const event = bufferer.wrapEvent(emitter.event);
			const listener = event(counter.onEvent, counter);

			assert.equal(counter.count, 0);
			emitter.fire();
			assert.equal(counter.count, 1);

			bufferer.bufferEvents(() => {
				emitter.fire();
				assert.equal(counter.count, 1);
				emitter.fire();
				assert.equal(counter.count, 1);
			});

			assert.equal(counter.count, 3);
			emitter.fire();
			assert.equal(counter.count, 4);

			listener.dispose();
		});

		
	});

	

	

	suite('buffer', () => {

		test('should buffer events', () => {
			const result: number[] = [];
			const emitter = new Emitter<number>();
			const event = emitter.event;
			const bufferedEvent = Event.buffer(event);

			emitter.fire(1);
			emitter.fire(2);
			emitter.fire(3);
			assert.deepEqual(result, []);

			const listener = bufferedEvent(num => result.push(num));
			assert.deepEqual(result, [1, 2, 3]);

			emitter.fire(4);
			assert.deepEqual(result, [1, 2, 3, 4]);

			listener.dispose();
			emitter.fire(5);
			assert.deepEqual(result, [1, 2, 3, 4]);
		});

		test('should buffer events on next tick', async () => {
			const result: number[] = [];
			const emitter = new Emitter<number>();
			const event = emitter.event;
			const bufferedEvent = Event.buffer(event, true);

			emitter.fire(1);
			emitter.fire(2);
			emitter.fire(3);
			assert.deepEqual(result, []);

			const listener = bufferedEvent(num => result.push(num));
			assert.deepEqual(result, []);

			await timeout(10);
			emitter.fire(4);
			assert.deepEqual(result, [1, 2, 3, 4]);
			listener.dispose();
			emitter.fire(5);
			assert.deepEqual(result, [1, 2, 3, 4]);
		});

		test('should fire initial buffer events', () => {
			const result: number[] = [];
			const emitter = new Emitter<number>();
			const event = emitter.event;
			const bufferedEvent = Event.buffer(event, false, [-2, -1, 0]);

			emitter.fire(1);
			emitter.fire(2);
			emitter.fire(3);
			assert.deepEqual(result, []);

			bufferedEvent(num => result.push(num));
			assert.deepEqual(result, [-2, -1, 0, 1, 2, 3]);
		});
	});

	suite('EventMultiplexer', () => {

		test('works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();
			m.event(r => result.push(r));

			const e1 = new Emitter<number>();
			m.add(e1.event);

			assert.deepEqual(result, []);

			e1.fire(0);
			assert.deepEqual(result, [0]);
		});

		test('multiplexer dispose works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();
			m.event(r => result.push(r));

			const e1 = new Emitter<number>();
			m.add(e1.event);

			assert.deepEqual(result, []);

			e1.fire(0);
			assert.deepEqual(result, [0]);

			m.dispose();
			assert.deepEqual(result, [0]);

			e1.fire(0);
			assert.deepEqual(result, [0]);
		});

		test('event dispose works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();
			m.event(r => result.push(r));

			const e1 = new Emitter<number>();
			m.add(e1.event);

			assert.deepEqual(result, []);

			e1.fire(0);
			assert.deepEqual(result, [0]);

			e1.dispose();
			assert.deepEqual(result, [0]);

			e1.fire(0);
			assert.deepEqual(result, [0]);
		});

		test('mutliplexer event dispose works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();
			m.event(r => result.push(r));

			const e1 = new Emitter<number>();
			const l1 = m.add(e1.event);

			assert.deepEqual(result, []);

			e1.fire(0);
			assert.deepEqual(result, [0]);

			l1.dispose();
			assert.deepEqual(result, [0]);

			e1.fire(0);
			assert.deepEqual(result, [0]);
		});

		test('hot start works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();
			m.event(r => result.push(r));

			const e1 = new Emitter<number>();
			m.add(e1.event);
			const e2 = new Emitter<number>();
			m.add(e2.event);
			const e3 = new Emitter<number>();
			m.add(e3.event);

			e1.fire(1);
			e2.fire(2);
			e3.fire(3);
			assert.deepEqual(result, [1, 2, 3]);
		});

		test('cold start works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();

			const e1 = new Emitter<number>();
			m.add(e1.event);
			const e2 = new Emitter<number>();
			m.add(e2.event);
			const e3 = new Emitter<number>();
			m.add(e3.event);

			m.event(r => result.push(r));

			e1.fire(1);
			e2.fire(2);
			e3.fire(3);
			assert.deepEqual(result, [1, 2, 3]);
		});

		test('late add works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();

			const e1 = new Emitter<number>();
			m.add(e1.event);
			const e2 = new Emitter<number>();
			m.add(e2.event);

			m.event(r => result.push(r));

			e1.fire(1);
			e2.fire(2);

			const e3 = new Emitter<number>();
			m.add(e3.event);
			e3.fire(3);

			assert.deepEqual(result, [1, 2, 3]);
		});

		test('add dispose works', () => {
			const result: number[] = [];
			const m = new EventMultiplexer<number>();

			const e1 = new Emitter<number>();
			m.add(e1.event);
			const e2 = new Emitter<number>();
			m.add(e2.event);

			m.event(r => result.push(r));

			e1.fire(1);
			e2.fire(2);

			const e3 = new Emitter<number>();
			const l3 = m.add(e3.event);
			e3.fire(3);
			assert.deepEqual(result, [1, 2, 3]);

			l3.dispose();
			e3.fire(4);
			assert.deepEqual(result, [1, 2, 3]);

			e2.fire(4);
			e1.fire(5);
			assert.deepEqual(result, [1, 2, 3, 4, 5]);
		});
	});

	
});



```







## Emitter constructor: (options: EmitterOptions)
```ts
export interface EmitterOptions {
	onFirstListenerAdd?: Function;
	onFirstListenerDidAdd?: Function;
	onListenerDidAdd?: Function;
	onLastListenerRemove?: Function;
	leakWarningThreshold?: number;
}
```

## emitter.event(handler, context, disposalStore)



## 









